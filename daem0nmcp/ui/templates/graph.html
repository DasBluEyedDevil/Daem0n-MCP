<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
          content="default-src 'none';
                   script-src 'unsafe-inline';
                   style-src 'unsafe-inline';
                   img-src data: blob:;">
    <title>{{TITLE}}</title>
    <style>
{{CSS}}

/* Graph-specific styles */
.graph-page {
    padding: var(--daemon-space-lg);
    height: 100vh;
    display: flex;
    flex-direction: column;
}
    </style>
</head>
<body>
    <div id="app" class="graph-page">
        <!-- Header Section -->
        <header class="graph-header">
            <div class="graph-header__title">
                <h1>{{TITLE}}</h1>
                <span class="graph-header__count">
                    {{NODE_COUNT}} nodes, {{EDGE_COUNT}} edges
                </span>
            </div>
        </header>

        <!-- Legend -->
        <div class="graph-legend">
            <div class="graph-legend__item">
                <span class="graph-legend__color graph-legend__color--decision"></span>
                <span>Decision</span>
            </div>
            <div class="graph-legend__item">
                <span class="graph-legend__color graph-legend__color--warning"></span>
                <span>Warning</span>
            </div>
            <div class="graph-legend__item">
                <span class="graph-legend__color graph-legend__color--pattern"></span>
                <span>Pattern</span>
            </div>
            <div class="graph-legend__item">
                <span class="graph-legend__color graph-legend__color--learning"></span>
                <span>Learning</span>
            </div>
        </div>

        <!-- Graph Container -->
        <div class="graph-container" id="graph-container">
            <!-- Canvas will be created by JavaScript -->

            <!-- Loading indicator with progress text -->
            <div class="graph-loading" id="loading">
                <div class="graph-loading__spinner"></div>
                <span id="loading-text">Loading graph...</span>
            </div>

            <!-- Empty state -->
            <div class="graph-empty" id="empty" style="display: none;">
                <p>No memories to display</p>
            </div>

            <!-- Zoom controls -->
            <div class="graph-controls">
                <button class="graph-controls__btn" id="zoom-in" title="Zoom in">+</button>
                <button class="graph-controls__btn" id="zoom-out" title="Zoom out">-</button>
                <button class="graph-controls__btn" id="zoom-reset" title="Reset zoom">R</button>
            </div>

            <!-- Community visibility toggle -->
            <div class="graph-controls graph-controls--top">
                <label class="graph-controls__toggle">
                    <input type="checkbox" id="show-communities" checked>
                    <span>Communities</span>
                </label>
            </div>

            <!-- Details panel -->
            <div class="graph-details" id="details-panel">
                <button class="graph-details__close" id="details-close">&times;</button>
                <div id="details-content"></div>
            </div>
        </div>
    </div>
    <script>
{{SCRIPT}}

// Memory Graph Viewer - Canvas-based Force-Directed Graph
(function() {
    // Parse graph data from template
    var graphData = {{GRAPH_DATA}};

    // Category colors (match daemon.css custom properties)
    var categoryColors = {
        'decision': '#3b82f6',
        'warning': '#f59e0b',
        'pattern': '#8b5cf6',
        'learning': '#22c55e',
        'default': '#888888'
    };

    // Relationship styles for edges
    var relationshipStyles = {
        'led_to': { color: '#3b82f6', dash: [] },
        'supersedes': { color: '#f59e0b', dash: [5, 5] },
        'conflicts_with': { color: '#ef4444', dash: [2, 2] },
        'relates_to': { color: '#888888', dash: [] },
        'depends_on': { color: '#22c55e', dash: [] }
    };

    // DOM elements
    var container = document.getElementById('graph-container');
    var loadingEl = document.getElementById('loading');
    var emptyEl = document.getElementById('empty');
    var detailsPanel = document.getElementById('details-panel');
    var detailsContent = document.getElementById('details-content');
    var detailsClose = document.getElementById('details-close');
    var zoomInBtn = document.getElementById('zoom-in');
    var zoomOutBtn = document.getElementById('zoom-out');
    var zoomResetBtn = document.getElementById('zoom-reset');

    // Canvas setup
    var canvas, ctx;
    var width, height;
    var dpr = window.devicePixelRatio || 1;

    // Simulation and transform state
    var simulation;
    var transform = d3.zoomIdentity;
    var zoomBehavior;

    // Node radius and selection state
    var nodeRadius = 8;
    var selectedNodeId = null;

    // Community visibility state
    var showCommunities = true;

    /**
     * Initialize canvas with retina support
     */
    function initCanvas() {
        width = container.clientWidth;
        height = container.clientHeight;

        canvas = document.createElement('canvas');
        canvas.className = 'graph-canvas';
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        // Insert canvas before loading indicator
        container.insertBefore(canvas, loadingEl);
    }

    /**
     * Draw an edge between two nodes
     */
    function drawEdge(source, target, relationship) {
        var style = relationshipStyles[relationship] || relationshipStyles['relates_to'];

        ctx.beginPath();
        ctx.strokeStyle = style.color;
        ctx.lineWidth = 1;
        ctx.setLineDash(style.dash);
        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    /**
     * Draw a node with category coloring and selection highlight
     */
    function drawNode(node) {
        var color = categoryColors[node.category] || categoryColors['default'];
        var isSelected = selectedNodeId !== null && node.id === selectedNodeId;

        ctx.beginPath();
        ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();

        // Selected node gets accent highlight stroke
        if (isSelected) {
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.stroke();
        } else {
            // Add subtle border for non-selected
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    /**
     * Main render function - called on each simulation tick
     */
    function draw() {
        ctx.save();
        ctx.clearRect(0, 0, width, height);

        // Apply zoom transform
        ctx.translate(transform.x, transform.y);
        ctx.scale(transform.k, transform.k);

        // Draw edges first (underneath nodes)
        graphData.edges.forEach(function(edge) {
            if (edge.source && edge.target && edge.source.x !== undefined) {
                drawEdge(edge.source, edge.target, edge.relationship);
            }
        });

        // Draw nodes
        graphData.nodes.forEach(function(node) {
            if (node.x !== undefined && node.y !== undefined) {
                drawNode(node);
            }
        });

        ctx.restore();
    }

    /**
     * Initialize D3 force simulation with provided nodes
     */
    function initSimulation(nodes, edges) {
        simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(edges)
                .id(function(d) { return d.id; })
                .strength(0.5)
                .distance(80))
            .force('charge', d3.forceManyBody()
                .strength(-100))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide(nodeRadius + 5))
            .alphaDecay(0.05)
            .on('tick', draw)
            .on('end', function() {
                loadingEl.classList.add('graph-loading--hidden');
            });
    }

    /**
     * Update loading progress text
     */
    function updateProgress(percent) {
        var progressText = document.getElementById('loading-text');
        if (progressText) {
            progressText.textContent = 'Loading... ' + Math.round(percent * 100) + '%';
        }
    }

    /**
     * Progressive loading for large graphs using requestIdleCallback
     * Loads nodes in batches during browser idle time to prevent UI freeze
     */
    function loadGraphProgressively(nodes, edges, onProgress, onComplete) {
        var BATCH_SIZE = 50;  // Nodes per idle callback
        var loadedNodes = [];
        var loaded = 0;
        var total = nodes.length;

        // Show loading indicator
        loadingEl.classList.remove('graph-loading--hidden');

        function loadBatch(deadline) {
            // Load nodes while we have idle time (at least 5ms remaining)
            while (loaded < total && deadline.timeRemaining() > 5) {
                loadedNodes.push(nodes[loaded]);
                loaded++;

                // Update progress and restart simulation periodically
                if (loaded % BATCH_SIZE === 0) {
                    if (simulation) {
                        simulation.nodes(loadedNodes);
                        simulation.alpha(0.3).restart();
                    }
                    onProgress(loaded / total);
                }
            }

            if (loaded < total) {
                // More nodes to load - schedule next batch
                requestIdleCallback(loadBatch);
            } else {
                // All nodes loaded - add edges and finalize
                if (simulation) {
                    simulation.nodes(loadedNodes);
                    simulation.force('link').links(edges);
                    simulation.alpha(1).restart();
                }
                loadingEl.classList.add('graph-loading--hidden');
                onComplete();
            }
        }

        // Initialize simulation with empty nodes first
        initSimulation([], []);

        // Start loading
        if (window.requestIdleCallback) {
            requestIdleCallback(loadBatch);
        } else {
            // Fallback for Safari (no requestIdleCallback support)
            // Load synchronously but update progress periodically
            var i = 0;
            function loadChunk() {
                var chunkEnd = Math.min(i + BATCH_SIZE, total);
                while (i < chunkEnd) {
                    loadedNodes.push(nodes[i]);
                    i++;
                }
                onProgress(i / total);

                if (i < total) {
                    // Use setTimeout to yield to browser
                    setTimeout(loadChunk, 0);
                } else {
                    // All loaded
                    simulation.nodes(loadedNodes);
                    simulation.force('link').links(edges);
                    simulation.alpha(1).restart();
                    loadingEl.classList.add('graph-loading--hidden');
                    onComplete();
                }
            }
            initSimulation([], []);
            loadChunk();
        }
    }

    /**
     * Initialize zoom behavior
     */
    function initZoom() {
        zoomBehavior = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', function(event) {
                transform = event.transform;
                draw();
            });

        d3.select(canvas).call(zoomBehavior);

        // Zoom control buttons
        zoomInBtn.addEventListener('click', function() {
            d3.select(canvas).transition().duration(300)
                .call(zoomBehavior.scaleBy, 1.3);
        });

        zoomOutBtn.addEventListener('click', function() {
            d3.select(canvas).transition().duration(300)
                .call(zoomBehavior.scaleBy, 0.7);
        });

        zoomResetBtn.addEventListener('click', function() {
            d3.select(canvas).transition().duration(300)
                .call(zoomBehavior.transform, d3.zoomIdentity);
        });
    }

    /**
     * Find node at given position (with transform applied)
     */
    function findNodeAtPosition(x, y) {
        // Inverse transform the coordinates
        var tx = (x - transform.x) / transform.k;
        var ty = (y - transform.y) / transform.k;

        // Use simulation.find for efficient quadtree lookup
        return simulation.find(tx, ty, nodeRadius * 2);
    }

    /**
     * Handle canvas click for node selection
     */
    function initClickHandler() {
        canvas.addEventListener('click', function(event) {
            var rect = canvas.getBoundingClientRect();
            var x = event.clientX - rect.left;
            var y = event.clientY - rect.top;

            var node = findNodeAtPosition(x, y);
            if (node) {
                showNodeDetails(node);
            }
        });

        // Close details panel and clear selection
        detailsClose.addEventListener('click', function() {
            detailsPanel.classList.remove('graph-details--visible');
            selectedNodeId = null;
            draw();
        });

        // Handle Focus button clicks via event delegation
        detailsContent.addEventListener('click', function(e) {
            var btn = e.target.closest('[data-action="focus"]');
            if (btn && window.SecureMessenger) {
                var memoryId = parseInt(btn.dataset.id, 10);
                SecureMessenger.send('tool_request', {
                    tool: 'get_graph',
                    args: { memory_ids: [memoryId], include_orphans: true }
                });
            }
        });
    }

    /**
     * Escape HTML for safe rendering
     */
    function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Format date for display
     */
    function formatDate(dateStr) {
        if (!dateStr) return '';
        try {
            var date = new Date(dateStr);
            return date.toLocaleDateString(undefined, {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        } catch (e) {
            return dateStr;
        }
    }

    /**
     * Show node details in side panel
     */
    function showNodeDetails(node) {
        // Build tags HTML
        var tagsHtml = '';
        if (node.tags && node.tags.length > 0) {
            tagsHtml = '<div class="result-card__tags" style="margin-top: var(--daemon-space-sm);">' +
                node.tags.map(function(t) {
                    return '<span class="result-card__tag">' + escapeHtml(t) + '</span>';
                }).join('') +
            '</div>';
        }

        // Build date HTML
        var dateHtml = '';
        if (node.created_at) {
            dateHtml = '<div style="margin-top: var(--daemon-space-sm); font-size: 0.75rem; color: var(--daemon-text-muted);">' +
                '<strong>Created:</strong> ' + escapeHtml(formatDate(node.created_at)) +
            '</div>';
        }

        // Get full content (not truncated)
        var fullContent = node.full_content || node.content || 'No content available';
        var titleContent = (node.content || '').substring(0, 80);
        if (titleContent.length < (node.content || '').length) {
            titleContent += '...';
        }

        detailsContent.innerHTML = [
            '<div class="daemon-card" style="padding: var(--daemon-space-md);">',
            '  <div class="daemon-badge daemon-badge--' + escapeHtml(node.category || 'default') + '">' + escapeHtml(node.category || 'memory') + '</div>',
            '  <h3 style="margin: var(--daemon-space-sm) 0;">' + escapeHtml(titleContent) + '</h3>',
            '  <p class="daemon-muted" style="font-size: 0.875rem; line-height: 1.6; margin-bottom: var(--daemon-space-md);">' + escapeHtml(fullContent) + '</p>',
            tagsHtml,
            dateHtml,
            '  <div style="margin-top: var(--daemon-space-sm); font-size: 0.75rem; color: var(--daemon-text-muted);">',
            '    <strong>ID:</strong> ' + escapeHtml(String(node.id)),
            '  </div>',
            '  <div style="margin-top: var(--daemon-space-md);">',
            '    <button class="daemon-btn daemon-btn--small" data-action="focus" data-id="' + escapeHtml(String(node.id)) + '">',
            '      Focus on this memory',
            '    </button>',
            '  </div>',
            '</div>'
        ].join('\n');

        // Update selection state and redraw to highlight
        selectedNodeId = node.id;
        detailsPanel.classList.add('graph-details--visible');
        draw();
    }

    /**
     * Handle window resize
     */
    function handleResize() {
        width = container.clientWidth;
        height = container.clientHeight;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        // Update force center
        if (simulation) {
            simulation.force('center', d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        }
    }

    // Progressive loading threshold (use for graphs larger than this)
    var PROGRESSIVE_THRESHOLD = 200;

    /**
     * Initialize the graph viewer
     */
    function init() {
        // Check for empty data
        if (!graphData.nodes || graphData.nodes.length === 0) {
            loadingEl.style.display = 'none';
            emptyEl.style.display = 'block';
            return;
        }

        // Initialize canvas first
        initCanvas();

        // Use progressive loading for large graphs to prevent UI freeze
        if (graphData.nodes.length > PROGRESSIVE_THRESHOLD) {
            loadGraphProgressively(
                graphData.nodes,
                graphData.edges,
                updateProgress,
                function() {
                    console.log('Graph loaded progressively: ' + graphData.nodes.length + ' nodes');
                }
            );
        } else {
            // Small graph - load directly
            initSimulation(graphData.nodes, graphData.edges);
        }

        // Initialize interaction handlers
        initZoom();
        initClickHandler();

        // Debounced resize handler
        var resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(handleResize, 250);
        });
    }

    // Start when DOM is ready
    document.addEventListener('DOMContentLoaded', init);
})();
    </script>
</body>
</html>
